import type { Language } from "../language.js";
import {
  identifier,
  keyword,
  number,
  parenthesis,
  string,
  surround,
} from "../pattern.js";

const joinPrefix = (prefix: string, words: string[]): string[] =>
  words.map((word) => `${prefix}${word}`);

const joinSurround = (
  prefix: string,
  words: string[],
  suffix: string,
): string[] => words.map((word) => `${prefix}${word}${suffix}`);

// spell-checker: disable
const builtins = [
  "scheme",
  // (scheme base)
  "*",
  "+",
  "-",
  "/",
  "<",
  "<=",
  "=",
  "=>",
  ">",
  ">=",
  "abs",
  "append",
  "apply",
  ...joinPrefix("ass", ["oc", "q", "v"]),
  "binary-port?",
  ...joinPrefix("boolean", ["=?", "?"]),
  ...joinPrefix("bytevector", [
    "",
    "-append",
    "-copy",
    "-copy!",
    "-length",
    "-u8-ref",
    "-u8-set!",
    "?",
  ]),
  "caar",
  "cadr",
  ...joinPrefix("call-with-", ["current-continuation", "port", "values"]),
  "call/cc",
  "car",
  "case",
  "cdar",
  "cddr",
  "cdr",
  "ceiling",
  ...joinPrefix("char", [
    "->integer",
    "-ready?",
    "<=?",
    "<?",
    "=?",
    ">=?",
    ">?",
    "?",
  ]),
  ...joinPrefix("close-", ["input-port", "output-port", "port"]),
  "complex?",
  "cons",
  ...joinSurround("current-", ["error", "input", "output"], "-port"),
  "denominator",
  "dynamic-wind",
  ...joinPrefix("eof-object", ["", "?"]),
  ...joinSurround("eq", ["", "ual", "v"], "?"),
  "error",
  ...joinPrefix("error-object", ["-irritants", "-message", "?"]),
  "even?",
  "exact",
  "exact-integer-sqrt",
  "exact-integer?",
  "exact?",
  "expt",
  "features",
  "file-error?",
  "floor",
  "floor-quotient",
  "floor-remainder",
  "floor/",
  "flush-output-port",
  "for-each",
  "gcd",
  "get-output-bytevector",
  "get-output-string",
  "inexact",
  "inexact?",
  "input-port-open?",
  "input-port?",
  "integer->char",
  "integer?",
  "lcm",
  "length",
  "list",
  "list->string",
  "list->vector",
  "list-copy",
  "list-ref",
  "list-set!",
  "list-tail",
  "list?",
  "make-bytevector",
  "make-list",
  "make-parameter",
  "make-string",
  "make-vector",
  "map",
  "max",
  "member",
  "memq",
  "memv",
  "min",
  "modulo",
  "negative?",
  "newline",
  "not",
  "null?",
  "number->string",
  "number?",
  "numerator",
  "odd?",
  "open-input-bytevector",
  "open-input-string",
  "open-output-bytevector",
  "open-output-string",
  "output-port-open?",
  "output-port?",
  "pair?",
  "peek-char",
  "peek-u8",
  "port?",
  "positive?",
  "procedure?",
  "quotient",
  "raise",
  "raise-continuable",
  "rational?",
  "rationalize",
  "read-bytevector",
  "read-bytevector!",
  "read-char",
  "read-error?",
  "read-line",
  "read-string",
  "read-u8",
  "real?",
  "remainder",
  "reverse",
  "round",
  "set-car!",
  "set-cdr!",
  "square",
  "string",
  "string->list",
  "string->number",
  "string->symbol",
  "string->utf8",
  "string->vector",
  "string-append",
  "string-copy",
  "string-copy!",
  "string-fill!",
  "string-for-each",
  "string-length",
  "string-map",
  "string-ref",
  "string-set!",
  "string<=?",
  "string<?",
  "string=?",
  "string>=?",
  "string>?",
  "string?",
  "substring",
  "symbol->string",
  "symbol=?",
  "symbol?",
  "textual-port?",
  "truncate",
  "truncate-quotient",
  "truncate-remainder",
  "truncate/",
  "u8-ready?",
  "utf8->string",
  "values",
  "vector",
  "vector->list",
  "vector->string",
  "vector-append",
  "vector-copy",
  "vector-copy!",
  "vector-fill!",
  "vector-for-each",
  "vector-length",
  "vector-map",
  "vector-ref",
  "vector-set!",
  "vector?",
  "with-exception-handler",
  "write-bytevector",
  "write-char",
  "write-string",
  "write-u8",
  "zero?",
  // (scheme char)
  "char-alphabetic?",
  "char-ci<=?",
  "char-ci<?",
  "char-ci=?",
  "char-ci>=?",
  "char-ci>?",
  "char-downcase",
  "char-foldcase",
  "char-lower-case?",
  "char-numeric?",
  "char-upcase",
  "char-upper-case?",
  "char-whitespace?",
  "digit-value",
  "string-ci<=?",
  "string-ci<?",
  "string-ci=?",
  "string-ci>=?",
  "string-ci>?",
  "string-downcase",
  "string-foldcase",
  "string-upcase",
  // (scheme cxr)
  "caaaar",
  "caaadr",
  "caaar",
  "caadar",
  "caaddr",
  "caadr",
  "cadaar",
  "cadadr",
  "cadar",
  "caddar",
  "cadddr",
  "caddr",
  "cdaaar",
  "cdaadr",
  "cdaar",
  "cdadar",
  "cdaddr",
  "cdadr",
  "cddaar",
  "cddadr",
  "cddar",
  "cdddar",
  "cddddr",
  "cdddr",
  // (scheme inexact)
  "acos",
  "asin",
  "atan",
  "cos",
  "exp",
  "finite?",
  "infinite?",
  "log",
  "nan?",
  "sin",
  "sqrt",
  "tan",
  // (scheme complex)
  "angle",
  "imag-part",
  "magnitude",
  "make-polar",
  "make-rectangular",
  "real-part",
  // (scheme lazy)
  "force",
  "make-promise",
  "promise?",
  // (scheme read)
  "read",
  // (scheme write)
  "display",
  "write",
  "write-shared",
  "write-simple",
  // (scheme eval)
  "environment",
  "eval",
  // (scheme repl)
  "interaction-environment",
  // (scheme load)
  "load",
  // (scheme file)
  "call-with-input-file",
  "call-with-output-file",
  "delete-file",
  "file-exists?",
  "open-binary-input-file",
  "open-binary-output-file",
  "open-input-file",
  "open-output-file",
  "with-input-from-file",
  "with-output-to-file",
  // (scheme time)
  "current-jiffy",
  "current-second",
  "jiffies-per-second",
  // (schmee process-context)
  "command-line",
  "emergency-exit",
  "exit",
  "get-environment-variable",
  "get-environment-variables",
];

const syntaxes = [
  // Library syntax
  "define-library",
  "export",
  "import",
  // (scheme base)
  "...",
  "and",
  "begin",
  "cond",
  "cond-expand",
  "define",
  "define-record-type",
  "define-syntax",
  "define-values",
  "do",
  "else",
  "guard",
  "if",
  "include",
  "include-ci",
  "lambda",
  "let",
  "let*",
  "let*-values",
  "let-syntax",
  "let-values",
  "letrec",
  "letrec*",
  "letrec-syntax",
  "or",
  "parameterize",
  "quasiquote",
  "quote",
  "set!",
  "syntax-error",
  "syntax-rules",
  "unless",
  "unquote",
  "unquote-splicing",
  "when",
  // (scheme case-lambda)
  "case-lambda",
  // (scheme lazy)
  "delay",
  "delay-force",
];
// spell-checker: enable

const symbolLetter = "[A-Za-z0-9-!?]";

export const scheme: Language = {
  lexers: [
    [surround(/;/, /[^\n]/, /\n/), ["comment"]],
    [surround(/#\|/, /[^|]|\|(?!#)/, /\|#/), ["comment"]],
    // spell-checker: disable-next-line
    [/^(#f(alse)?|#t(rue)?|#\\[a-z0-9]+)/, ["constant"]],
    [number, ["number", "constant"]],
    [string, ["string"]],
    [parenthesis, ["punctuation"]],
    [keyword(builtins, symbolLetter), ["variable"]],
    [keyword(syntaxes, symbolLetter), ["keyword"]],
    [identifier(symbolLetter, symbolLetter), []],
    [/^('|`|,|,@|#;)/, ["punctuation"]],
  ],
};
